// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stream.sql

package stream

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const createRecording = `-- name: CreateRecording :exec

INSERT INTO "Recording" (
  id, "streamId", "fileUrl", duration, size
) VALUES (
  $1, $2, $3, $4, $5
)
`

type CreateRecordingParams struct {
	ID       string
	StreamId string
	FileUrl  string
	Duration sql.NullInt32
	Size     sql.NullInt64
}

// =========================
// RECORDING
// =========================
func (q *Queries) CreateRecording(ctx context.Context, arg CreateRecordingParams) error {
	_, err := q.db.ExecContext(ctx, createRecording,
		arg.ID,
		arg.StreamId,
		arg.FileUrl,
		arg.Duration,
		arg.Size,
	)
	return err
}

const createStream = `-- name: CreateStream :exec

INSERT INTO "Stream" (
  id, "userId", title, description, visibility
) VALUES (
  $1, $2, $3, $4, $5
)
`

type CreateStreamParams struct {
	ID          string
	UserId      string
	Title       string
	Description sql.NullString
	Visibility  interface{}
}

// =========================
// STREAM
// =========================
func (q *Queries) CreateStream(ctx context.Context, arg CreateStreamParams) error {
	_, err := q.db.ExecContext(ctx, createStream,
		arg.ID,
		arg.UserId,
		arg.Title,
		arg.Description,
		arg.Visibility,
	)
	return err
}

const createStreamEvent = `-- name: CreateStreamEvent :exec

INSERT INTO "StreamEvent" (
  id, "streamId", type, payload
) VALUES (
  $1, $2, $3, $4
)
`

type CreateStreamEventParams struct {
	ID       string
	StreamId string
	Type     interface{}
	Payload  pqtype.NullRawMessage
}

// =========================
// STREAM EVENT
// =========================
func (q *Queries) CreateStreamEvent(ctx context.Context, arg CreateStreamEventParams) error {
	_, err := q.db.ExecContext(ctx, createStreamEvent,
		arg.ID,
		arg.StreamId,
		arg.Type,
		arg.Payload,
	)
	return err
}

const createStreamMeta = `-- name: CreateStreamMeta :exec
INSERT INTO "StreamMeta" (
  id, "streamId", "totalDuration", "segmentDuration", "timescale", "videoRepId", "audioRepId", "basePath"
) VALUES (
  $1, $2, 0, $3, $4, $5, $6, $7
)
`

type CreateStreamMetaParams struct {
	ID              string
	StreamId        string
	SegmentDuration int32
	Timescale       int32
	VideoRepId      string
	AudioRepId      string
	BasePath        sql.NullString
}

func (q *Queries) CreateStreamMeta(ctx context.Context, arg CreateStreamMetaParams) error {
	_, err := q.db.ExecContext(ctx, createStreamMeta,
		arg.ID,
		arg.StreamId,
		arg.SegmentDuration,
		arg.Timescale,
		arg.VideoRepId,
		arg.AudioRepId,
		arg.BasePath,
	)
	return err
}

const disableStreamKey = `-- name: DisableStreamKey :exec
UPDATE "StreamKey"
SET "isActive" = FALSE
WHERE "streamId" = $1
`

func (q *Queries) DisableStreamKey(ctx context.Context, streamid string) error {
	_, err := q.db.ExecContext(ctx, disableStreamKey, streamid)
	return err
}

const existStreamMeta = `-- name: ExistStreamMeta :one
SELECT EXISTS (
  SELECT 1
  FROM "StreamMeta"
  WHERE "streamId" = $1
)
`

func (q *Queries) ExistStreamMeta(ctx context.Context, streamid string) (bool, error) {
	row := q.db.QueryRowContext(ctx, existStreamMeta, streamid)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getActiveStreamKey = `-- name: GetActiveStreamKey :one

SELECT id, "streamId", "keyHash", "isActive", "expiresAt", "lastUsedAt", "createdAt"
FROM "StreamKey"
WHERE "streamId" = $1
  AND "isActive" = TRUE
  AND ("expiresAt" IS NULL OR "expiresAt" > now())
`

// =========================
// STREAM KEY
// =========================
func (q *Queries) GetActiveStreamKey(ctx context.Context, streamid string) (StreamKey, error) {
	row := q.db.QueryRowContext(ctx, getActiveStreamKey, streamid)
	var i StreamKey
	err := row.Scan(
		&i.ID,
		&i.StreamId,
		&i.KeyHash,
		&i.IsActive,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getLiveStreamByID = `-- name: GetLiveStreamByID :one
SELECT id, "userId", title, description, "isLive", visibility, "startedAt", "endedAt", "createdAt", "updatedAt"
FROM "Stream"
WHERE id = $1
  AND "isLive" = TRUE
`

func (q *Queries) GetLiveStreamByID(ctx context.Context, id string) (Stream, error) {
	row := q.db.QueryRowContext(ctx, getLiveStreamByID, id)
	var i Stream
	err := row.Scan(
		&i.ID,
		&i.UserId,
		&i.Title,
		&i.Description,
		&i.IsLive,
		&i.Visibility,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOldEndedStreamIDs = `-- name: GetOldEndedStreamIDs :many
SELECT id
FROM "Stream"
WHERE "isLive" = FALSE
  AND "endedAt" IS NOT NULL
  AND "endedAt" < $1
`

func (q *Queries) GetOldEndedStreamIDs(ctx context.Context, endedat sql.NullTime) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getOldEndedStreamIDs, endedat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordingsByStream = `-- name: GetRecordingsByStream :many
SELECT id, "streamId", "fileUrl", duration, size, "createdAt"
FROM "Recording"
WHERE "streamId" = $1
ORDER BY "createdAt" DESC
`

func (q *Queries) GetRecordingsByStream(ctx context.Context, streamid string) ([]Recording, error) {
	rows, err := q.db.QueryContext(ctx, getRecordingsByStream, streamid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recording
	for rows.Next() {
		var i Recording
		if err := rows.Scan(
			&i.ID,
			&i.StreamId,
			&i.FileUrl,
			&i.Duration,
			&i.Size,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoppedStreamIDs = `-- name: GetStoppedStreamIDs :many

SELECT DISTINCT se."streamId"
FROM "StreamEvent" se
WHERE se.type = 'STREAM_STOP'
  AND se."createdAt" > $1
`

// ============================================
// GARBAGE COLLECTION QUERIES
// ============================================
func (q *Queries) GetStoppedStreamIDs(ctx context.Context, createdat time.Time) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getStoppedStreamIDs, createdat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var streamId string
		if err := rows.Scan(&streamId); err != nil {
			return nil, err
		}
		items = append(items, streamId)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreamByID = `-- name: GetStreamByID :one
SELECT id, "userId", title, description, "isLive", visibility, "startedAt", "endedAt", "createdAt", "updatedAt"
FROM "Stream"
WHERE id = $1
`

func (q *Queries) GetStreamByID(ctx context.Context, id string) (Stream, error) {
	row := q.db.QueryRowContext(ctx, getStreamByID, id)
	var i Stream
	err := row.Scan(
		&i.ID,
		&i.UserId,
		&i.Title,
		&i.Description,
		&i.IsLive,
		&i.Visibility,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStreamEvents = `-- name: GetStreamEvents :many
SELECT id, "streamId", type, payload, "createdAt"
FROM "StreamEvent"
WHERE "streamId" = $1
ORDER BY "createdAt" DESC
LIMIT $2
`

type GetStreamEventsParams struct {
	StreamId string
	Limit    int32
}

func (q *Queries) GetStreamEvents(ctx context.Context, arg GetStreamEventsParams) ([]StreamEvent, error) {
	rows, err := q.db.QueryContext(ctx, getStreamEvents, arg.StreamId, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StreamEvent
	for rows.Next() {
		var i StreamEvent
		if err := rows.Scan(
			&i.ID,
			&i.StreamId,
			&i.Type,
			&i.Payload,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreamMeta = `-- name: GetStreamMeta :one

SELECT id, "streamId", "totalDuration", "segmentCount", "lastSegmentSeq", "segmentDuration", timescale, "videoRepId", "audioRepId", "basePath", "createdAt", "updatedAt" FROM "StreamMeta"
WHERE "streamId" = $1
`

// =========================
// STREAM META
// =========================
func (q *Queries) GetStreamMeta(ctx context.Context, streamid string) (StreamMetum, error) {
	row := q.db.QueryRowContext(ctx, getStreamMeta, streamid)
	var i StreamMetum
	err := row.Scan(
		&i.ID,
		&i.StreamId,
		&i.TotalDuration,
		&i.SegmentCount,
		&i.LastSegmentSeq,
		&i.SegmentDuration,
		&i.Timescale,
		&i.VideoRepId,
		&i.AudioRepId,
		&i.BasePath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLiveStreams = `-- name: ListLiveStreams :many
SELECT id, "userId", title, description, "isLive", visibility, "startedAt", "endedAt", "createdAt", "updatedAt"
FROM "Stream"
WHERE "isLive" = TRUE
ORDER BY "createdAt" DESC
LIMIT $1
`

func (q *Queries) ListLiveStreams(ctx context.Context, limit int32) ([]Stream, error) {
	rows, err := q.db.QueryContext(ctx, listLiveStreams, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stream
	for rows.Next() {
		var i Stream
		if err := rows.Scan(
			&i.ID,
			&i.UserId,
			&i.Title,
			&i.Description,
			&i.IsLive,
			&i.Visibility,
			&i.StartedAt,
			&i.EndedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setStreamStarted = `-- name: SetStreamStarted :exec
UPDATE "Stream"
SET "startedAt" = now(),
    "updatedAt" = now()
WHERE id = $1
`

func (q *Queries) SetStreamStarted(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, setStreamStarted, id)
	return err
}

const touchStreamKey = `-- name: TouchStreamKey :exec
UPDATE "StreamKey"
SET "lastUsedAt" = now()
WHERE "streamId" = $1
`

func (q *Queries) TouchStreamKey(ctx context.Context, streamid string) error {
	_, err := q.db.ExecContext(ctx, touchStreamKey, streamid)
	return err
}

const updateStreamInfo = `-- name: UpdateStreamInfo :exec
UPDATE "Stream"
SET title = $2,
    description = $3,
    visibility = $4,
    "updatedAt" = now()
WHERE id = $1
`

type UpdateStreamInfoParams struct {
	ID          string
	Title       string
	Description sql.NullString
	Visibility  interface{}
}

func (q *Queries) UpdateStreamInfo(ctx context.Context, arg UpdateStreamInfoParams) error {
	_, err := q.db.ExecContext(ctx, updateStreamInfo,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Visibility,
	)
	return err
}

const updateStreamLive = `-- name: UpdateStreamLive :exec
UPDATE "Stream"
SET "isLive" = $2,
    "endedAt" = CASE WHEN $2 = FALSE THEN now() ELSE NULL END,
    "updatedAt" = now()
WHERE id = $1
`

type UpdateStreamLiveParams struct {
	ID     string
	IsLive bool
}

func (q *Queries) UpdateStreamLive(ctx context.Context, arg UpdateStreamLiveParams) error {
	_, err := q.db.ExecContext(ctx, updateStreamLive, arg.ID, arg.IsLive)
	return err
}

const updateStreamMeta = `-- name: UpdateStreamMeta :exec
UPDATE "StreamMeta"
SET "totalDuration" = $2,
    "segmentCount" = $3,
    "lastSegmentSeq" = $4,
    "segmentDuration" = $5,
    "timescale" = $6,
    "videoRepId" = $7,
    "audioRepId" = $8,
    "basePath" = $9,
    "updatedAt" = now()
WHERE "streamId" = $1
`

type UpdateStreamMetaParams struct {
	StreamId        string
	TotalDuration   float64
	SegmentCount    sql.NullInt32
	LastSegmentSeq  sql.NullInt32
	SegmentDuration int32
	Timescale       int32
	VideoRepId      string
	AudioRepId      string
	BasePath        sql.NullString
}

func (q *Queries) UpdateStreamMeta(ctx context.Context, arg UpdateStreamMetaParams) error {
	_, err := q.db.ExecContext(ctx, updateStreamMeta,
		arg.StreamId,
		arg.TotalDuration,
		arg.SegmentCount,
		arg.LastSegmentSeq,
		arg.SegmentDuration,
		arg.Timescale,
		arg.VideoRepId,
		arg.AudioRepId,
		arg.BasePath,
	)
	return err
}

const updateStreamMetaWithSegments = `-- name: UpdateStreamMetaWithSegments :exec

UPDATE "StreamMeta"
SET "totalDuration" = $2,
    "segmentCount" = $3,
    "lastSegmentSeq" = $4,
    "segmentDuration" = $5,
    "timescale" = $6,
    "videoRepId" = $7,
    "audioRepId" = $8,
    "basePath" = $9,
    "updatedAt" = now()
WHERE "streamId" = $1
`

type UpdateStreamMetaWithSegmentsParams struct {
	StreamId        string
	TotalDuration   float64
	SegmentCount    sql.NullInt32
	LastSegmentSeq  sql.NullInt32
	SegmentDuration int32
	Timescale       int32
	VideoRepId      string
	AudioRepId      string
	BasePath        sql.NullString
}

// ============================================
// META QUERIES
// ============================================
func (q *Queries) UpdateStreamMetaWithSegments(ctx context.Context, arg UpdateStreamMetaWithSegmentsParams) error {
	_, err := q.db.ExecContext(ctx, updateStreamMetaWithSegments,
		arg.StreamId,
		arg.TotalDuration,
		arg.SegmentCount,
		arg.LastSegmentSeq,
		arg.SegmentDuration,
		arg.Timescale,
		arg.VideoRepId,
		arg.AudioRepId,
		arg.BasePath,
	)
	return err
}
